/*! For license information please see index.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("react"));else if("function"==typeof define&&define.amd)define(["react"],e);else{var n="object"==typeof exports?e(require("react")):e(t.react);for(var r in n)("object"==typeof exports?exports:t)[r]=n[r]}}(self,(t=>(()=>{"use strict";var e={155:e=>{e.exports=t}},n={};function r(t){var i=n[t];if(void 0!==i)return i.exports;var o=n[t]={exports:{}};return e[t](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var i={};r.r(i),r.d(i,{useAudioProcessorKit:()=>x});var o,a,s,u,c,l=r(155),h={PAUSE:2,RESUME:4,STOP:3,INIT:1,SPEAKING_STARTED:10,SPEAKING_STOPED:12},f=new Blob(["\n\nclass AudioProcessor extends AudioWorkletProcessor {\n\n    constructor() {\n        super();\n        console.log(\"Hello :) from AudioProcessor V4\");\n        this._readyTolisten = false;\n        this._needToSaveAudio = false;\n        this._enableVad = false;\n\n        /**\n         * WebAudio calls process() every time, we can't replace it.\n         * So we use _runtimeProcess inside it, and change _runtimeProcess\n         * to whatever function we need (like with VAD or without).\n         * This way we avoid if checks and get better performance.\n         */\n        this._runtimeProcess = () => true; // default dummy function\n\n        /**\n         * variables for vad feature\n         */\n        this._peakNoticedFrameCount = 0;\n        this._peakMaxFrame = 30;//sound start 60ms\n        this._silenceNoticedFrameCount = 0;\n        this._silentMaxFrame = 70; // 70 FRAME OF EACH 3MS TO 60*3 GIVES '180MS' OF SILENT MEANS TRIGGERS\n        this._facedAnyPeakVolume = false; // a variable which allow to vad to save if meet peak condtion\n\n        /**\n         * variables for need to save audio to record total session from start to stop\n         */\n        this._totalSessionLength = 0;\n        this._totalSession = [];\n\n        /**\n         * variables for need to save audio per given Time in frame or based on VAD\n         */\n        this._buffer2dArray16Bit = [];\n        this._buffer2dpreCaluculatingLength = 0;\n\n\n        /**\n         * for Volume level of audio needed for virtualization and others\n         * this rms volume data is update to main thread per the given frame\n         */\n        this._VolumeUpdateframe = 5; //15MS to get 60 frame rate like smooth\n        this._currentVolumeFrame = 0;\n\n        /***\n         * calls callback to get pass audio chunk data in nonvad senario data to main thread by  given frame time\n         */\n        this.secondsInFrame = 1000 / 3; //3 ms apprx be the time to call process , here 1s default time\n        this.currentSecondsIn = 0;\n\n\n\n\n        /**\n         *  Communicate with main thread\n         */\n        this.port.onmessage = (event) => {\n            const params = event.data;\n            switch (params.status) {\n                case 1://this.signal.INIT\n                    this._initialAssign(params);\n                    this._chooseProcess();\n\n                    break;\n                case this.signal.PAUSE:\n                    this._readyTolisten = false;\n\n                    break;\n                case this.signal.RESUME:\n                    this._readyTolisten = true;\n\n                    break;\n                case this.signal.STOP:\n                    this._readyTolisten = false;\n\n                    if (this._needToSaveAudio) {\n                        const transferList = this._totalSession.map(chunk => chunk.buffer);\n                        this.port.postMessage({\n                            status: this.signal.SPEAKING_STOPED,\n                            chunks: this._totalSession,\n                            length: this._totalSessionLength\n                        }, transferList);\n                        this._totalSession = [];\n                        this._totalSessionLength = 0;\n                    }\n\n                    break;\n                default:\n                    console.log(\"not matching status key\");\n            }\n        };\n    }\n\n    _initialAssign(params) {\n        this.signal = params.signal;\n        this._readyTolisten = true;\n        this.enableVad = params.enableVad;\n        this._needToSaveAudio = params.fullRecording;\n    }\n\n    /**\n     * logic to assign audioworklet process function to a function refrent  wich only do the nesscery work ,Not other things\n     *  to reduce performance\n     */\n    _chooseProcess() {\n        if (this.enableVad && this._needToSaveAudio) {\n            this._runtimeProcess = this.Process_With_Vad_And_FullRecording.bind(this);\n        } else if (this.enableVad) {\n            this._runtimeProcess = this.Process_With_Vad.bind(this);\n        } else {\n            this._runtimeProcess = this.Process_Without_vad_and_FullRecording.bind(this);\n        }\n        // why this pattern ? it reduce braching improve performance way more\n    }\n\n    /**\n     * Main function wich is called by browsers per approx 2 to 3 ms gap to give real audio buffers \n     * currently i made this way that this function can dynamically change its task \n     * by assiging any other function to  runtimeProcess this variable i used to\n     * assigin function dynamically that run inside this process ; \n     * this way i reduce condtions if-else usally happen when  pull all code inside this small tight loop\n     * \n     * This way very helpfully of removing cpu instuction branching , and make this very performant.\n     *  \n     */\n    process(inputs, outputs, parameters) { \n        if (!this._readyTolisten) return true; // Keep process alive by returning true\n\n        return this._runtimeProcess(inputs, outputs, parameters);\n    }\n\n    \n\n    Process_Without_vad_and_FullRecording(inputs, outputs, parameters) {\n\n        const input = inputs[0];\n\n        const channelData = input[0]; // taking first channel\n        if (this.currentSecondsIn > this.secondsInFrame) {\n            const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n            this.port.postMessage({\n                status: this.signal.SPEAKING_STOPED,\n                // speaking: false,\n                chunks: this._buffer2dArray16Bit,\n                length: this._buffer2dpreCaluculatingLength\n            }, transferList);\n\n            this.currentSecondsIn = 0;\n            this._buffer2dArray16Bit = [];\n            this._buffer2dpreCaluculatingLength = 0;\n            return true;\n        } else {\n            this.currentSecondsIn++;\n        }\n        const converted16bit_array = this.float32ToInt16(channelData);\n        this._buffer2dArray16Bit.push(converted16bit_array);\n        this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n\n        // Keep process alive\n        return true;\n    }\n\n\n    Process_With_Vad_And_FullRecording(inputs, outputs, parameters) {\n        const input = inputs[0];\n        if (input.length) {\n\n            const channelData = input[0]; // taking first channel\n            //faced any peak audio is important because it ensure we not passing empty data to backed\n            if (this.isSilent(channelData)) {\n\n                if (!this._facedAnyPeakVolume) {\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\n                    return true;   //early exit not valid audio\n                }\n\n\n                this._silenceNoticedFrameCount++;\n\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n\n                    this.port.postMessage({\n                        status: this.signal.SPEAKING_STOPED,\n                        // speaking: false,\n                        chunks: this._buffer2dArray16Bit,\n                        length: this._buffer2dpreCaluculatingLength\n                    }, transferList);\n\n                    this._buffer2dArray16Bit = [];\n                    this._buffer2dpreCaluculatingLength = 0;\n                    this._silenceNoticedFrameCount = 0;\n                    this._facedAnyPeakVolume = false;\n                    this._peakNoticedFrameCount = 0;\n                    return true;\n                }\n\n\n            } else {\n                // here the logic is i show is speaking data after some real word passed so i wait 180 ms of continuos speach before declaring it is speaking\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\n                    // Notify UI that voice HEARD and may started speaking\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\n                    this._facedAnyPeakVolume = true;\n                }\n\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\n                this._silenceNoticedFrameCount = 0;\n\n            }\n\n            const converted16bit_array = this.float32ToInt16(channelData);\n            this._totalSession.push(new Int16Array(converted16bit_array));\n            this._buffer2dArray16Bit.push(converted16bit_array);\n            this._totalSessionLength += converted16bit_array.length;\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n\n        }\n\n       // Keep process alive\n        return true;\n    }\n\n    Process_With_Vad(inputs, outputs, parameters) {\n        const input = inputs[0];\n        if (input.length) {\n\n            const channelData = input[0]; // taking first channel\n            //faced any peak audio is important because it ensure we not passing empty data to backed\n            if (this.isSilent(channelData)) {\n\n                if (!this._facedAnyPeakVolume) {\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\n                    return true;   //early exit not valid audio\n                }\n\n\n                this._silenceNoticedFrameCount++;\n\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n\n                    this.port.postMessage({\n                        status: this.signal.SPEAKING_STOPED,\n                        // speaking: false,\n                        chunks: this._buffer2dArray16Bit,\n                        length: this._buffer2dpreCaluculatingLength\n                    }, transferList);\n\n                    this._buffer2dArray16Bit = [];\n                    this._buffer2dpreCaluculatingLength = 0;\n                    this._silenceNoticedFrameCount = 0;\n                    this._facedAnyPeakVolume = false;\n                    this._peakNoticedFrameCount = 0;\n                    return true;\n                }\n\n\n            } else {\n                // here the logic is To recogonise speaking i wait for some time to get notice peak voice\n               //  for some Milli second  of continuos speach before declaring it is speaking.\n\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\n                    // Notify UI that voice HEARD and may started speaking\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\n                    this._facedAnyPeakVolume = true;\n                }\n\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\n                this._silenceNoticedFrameCount = 0;\n\n            }\n\n            const converted16bit_array = this.float32ToInt16(channelData);\n            this._buffer2dArray16Bit.push(converted16bit_array);\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n        }\n\n        // Keep process alive\n        return true;\n    }\n\n\n    /**\n     * Convert 32 bit float to 16 bit int\n     * example\n     * [\n     *  1.99999988079071044921875  to normalize between 16 bit int meaning convert under 35000\n     *  by just multipling point number to 35000 and also (32000 for negative value )\n     *  by this we get convert 32 bit to 16 bit\n     *  int\n     * ]\n     * @param {*} float32Array\n     * @returns INTEGER\n     */\n    float32ToInt16(float32Array) {\n        const int16Array = new Int16Array(128);\n        for (let i = 0; i < 128; i++) {\n            let s = Math.max(-1, Math.min(1, float32Array[i]));\n            int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n        }\n        return int16Array;\n    }\n\n    /**\n     * get silent and peak from value under 0 to 1\n     *\n     * v3 - new changes\n     * In this version i simply only checking half value\n     * it is ok till we get positive result same reslt not major accurasy issue\n     * and get performance bost\n     *\n     * @param {*} buffer\n     * @returns float\n     */\n    getRMS(buffer) {\n        let sumSquares = 0;\n        /**\n         * idea is to get a single value from 0 to 1 from all 128 values from this list;\n         * mathematically just 20/100 gives 0.2 like that adding each  give 128 value and total is 128.\n         * which is 128/128 gives 1\n         *\n         * this is base idea other than it all normallization of each single 128 value\n         * like if value is minus making is positive ,  any way it will not exede 1 so allways\n         * its total lesst than or equal to 128 why becaous is each maxmimum is 1 then 1*128 gives 128\n         *\n         * finally sqaure rooting to get lowest round value we are doing this\n         * without it also we can work in this\n         *\n         */\n        for (let i = 0; i < 128; i++) {\n            sumSquares += buffer[i] * buffer[i];\n        }\n        /**\n         *  here constent 0.0078125 equivalent of 128  basically iam doing division in fastest way\n         *  multiplicational divition is faster than actual division in cpu\n         *  1/128 gives 0.0078125 simply just multiply by it you get its value\n         */\n        return Math.sqrt(sumSquares * 0.0078125);\n    }\n\n    /**\n     * analyse for silence in audio bit\n     * with our given constant value\n     * @param {*} buffer 128 32bit float\n     * @returns boolean\n     */\n    isSilent(buffer) {\n        const rms = this.getRMS(buffer);\n        // this.port.postMessage({\n        //     status: 15,\n        //     volume: rms,\n        // });\n        if (this._currentVolumeFrame > this._VolumeUpdateframe) {\n            this._currentVolumeFrame = 0;\n            this.port.postMessage({\n                status: 15,\n                volume: rms,\n            });\n        } else {\n            this._currentVolumeFrame++;\n        }\n\n        return rms < 0.003;\n    }\n\n\n\n}\n\n\n   registerProcessor('audio-processor', AudioProcessor);\n"],{type:"application/javascript"}),d=URL.createObjectURL(f);function p(t){return p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},p(t)}function m(){m=function(){return e};var t,e={},n=Object.prototype,r=n.hasOwnProperty,i=Object.defineProperty||function(t,e,n){t[e]=n.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",u=o.toStringTag||"@@toStringTag";function c(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{c({},"")}catch(t){c=function(t,e,n){return t[e]=n}}function l(t,e,n,r){var o=e&&e.prototype instanceof b?e:b,a=Object.create(o.prototype),s=new N(r||[]);return i(a,"_invoke",{value:T(t,n,s)}),a}function h(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(t){return{type:"throw",arg:t}}}e.wrap=l;var f="suspendedStart",d="suspendedYield",y="executing",v="completed",g={};function b(){}function _(){}function w(){}var S={};c(S,a,(function(){return this}));var k=Object.getPrototypeOf,A=k&&k(k(I([])));A&&A!==n&&r.call(A,a)&&(S=A);var E=w.prototype=b.prototype=Object.create(S);function x(t){["next","throw","return"].forEach((function(e){c(t,e,(function(t){return this._invoke(e,t)}))}))}function P(t,e){function n(i,o,a,s){var u=h(t[i],t,o);if("throw"!==u.type){var c=u.arg,l=c.value;return l&&"object"==p(l)&&r.call(l,"__await")?e.resolve(l.__await).then((function(t){n("next",t,a,s)}),(function(t){n("throw",t,a,s)})):e.resolve(l).then((function(t){c.value=t,a(c)}),(function(t){return n("throw",t,a,s)}))}s(u.arg)}var o;i(this,"_invoke",{value:function(t,r){function i(){return new e((function(e,i){n(t,r,e,i)}))}return o=o?o.then(i,i):i()}})}function T(e,n,r){var i=f;return function(o,a){if(i===y)throw Error("Generator is already running");if(i===v){if("throw"===o)throw a;return{value:t,done:!0}}for(r.method=o,r.arg=a;;){var s=r.delegate;if(s){var u=L(s,r);if(u){if(u===g)continue;return u}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(i===f)throw i=v,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);i=y;var c=h(e,n,r);if("normal"===c.type){if(i=r.done?v:d,c.arg===g)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(i=v,r.method="throw",r.arg=c.arg)}}}function L(e,n){var r=n.method,i=e.iterator[r];if(i===t)return n.delegate=null,"throw"===r&&e.iterator.return&&(n.method="return",n.arg=t,L(e,n),"throw"===n.method)||"return"!==r&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+r+"' method")),g;var o=h(i,e.iterator,n.arg);if("throw"===o.type)return n.method="throw",n.arg=o.arg,n.delegate=null,g;var a=o.arg;return a?a.done?(n[e.resultName]=a.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=t),n.delegate=null,g):a:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,g)}function F(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function O(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function N(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(F,this),this.reset(!0)}function I(e){if(e||""===e){var n=e[a];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function n(){for(;++i<e.length;)if(r.call(e,i))return n.value=e[i],n.done=!1,n;return n.value=t,n.done=!0,n};return o.next=o}}throw new TypeError(p(e)+" is not iterable")}return _.prototype=w,i(E,"constructor",{value:w,configurable:!0}),i(w,"constructor",{value:_,configurable:!0}),_.displayName=c(w,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===_||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,w):(t.__proto__=w,c(t,u,"GeneratorFunction")),t.prototype=Object.create(E),t},e.awrap=function(t){return{__await:t}},x(P.prototype),c(P.prototype,s,(function(){return this})),e.AsyncIterator=P,e.async=function(t,n,r,i,o){void 0===o&&(o=Promise);var a=new P(l(t,n,r,i),o);return e.isGeneratorFunction(n)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},x(E),c(E,u,"Generator"),c(E,a,(function(){return this})),c(E,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),n=[];for(var r in e)n.push(r);return n.reverse(),function t(){for(;n.length;){var r=n.pop();if(r in e)return t.value=r,t.done=!1,t}return t.done=!0,t}},e.values=I,N.prototype={constructor:N,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(O),!e)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function i(r,i){return s.type="throw",s.arg=e,n.next=r,i&&(n.method="next",n.arg=t),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],s=a.completion;if("root"===a.tryLoc)return i("end");if(a.tryLoc<=this.prev){var u=r.call(a,"catchLoc"),c=r.call(a,"finallyLoc");if(u&&c){if(this.prev<a.catchLoc)return i(a.catchLoc,!0);if(this.prev<a.finallyLoc)return i(a.finallyLoc)}else if(u){if(this.prev<a.catchLoc)return i(a.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return i(a.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,g):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),g},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),O(n),g}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var r=n.completion;if("throw"===r.type){var i=r.arg;O(n)}return i}}throw Error("illegal catch attempt")},delegateYield:function(e,n,r){return this.delegate={iterator:I(e),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=t),g}},e}function y(t,e){if(t){if("string"==typeof t)return v(t,e);var n={}.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?v(t,e):void 0}}function v(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=Array(e);n<e;n++)r[n]=t[n];return r}function g(t,e,n,r,i,o,a){try{var s=t[o](a),u=s.value}catch(t){return void n(t)}s.done?e(u):Promise.resolve(u).then(r,i)}function b(t){return function(){var e=this,n=arguments;return new Promise((function(r,i){var o=t.apply(e,n);function a(t){g(o,r,i,a,s,"next",t)}function s(t){g(o,r,i,a,s,"throw",t)}a(void 0)}))}}var _=new((null===(o=window)||void 0===o?void 0:o.AudioContext)||(null===(a=window)||void 0===a?void 0:a.webkitAudioContext)),w=null==_||null===(s=_.audioWorklet)||void 0===s||null===(u=s.addModule)||void 0===u?void 0:u.call(s,d);function S(){return k.apply(this,arguments)}function k(){return(k=b(m().mark((function t(){return m().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(t.prev=0,w){t.next=3;break}throw new Error("issue with initializing audioWorklet addModule , please use https or localhost");case 3:return t.next=5,w;case 5:return t.abrupt("return",_);case 8:return t.prev=8,t.t0=t.catch(0),console.error(t.t0),t.abrupt("return",void 0);case 12:case"end":return t.stop()}}),t,null,[[0,8]])})))).apply(this,arguments)}null==w||null===(c=w.catch)||void 0===c||c.call(w,(function(t){console.log("not able add addModule audioProcessor.js ")}));function A(t,e){return E.apply(this,arguments)}function E(){return(E=b(m().mark((function t(e,n){var r,i,o,a;return m().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.prev=0,t.next=3,S();case 3:if(r=t.sent){t.next=6;break}throw new Error("issue with initializing audioContext");case 6:return t.next=8,navigator.mediaDevices.getUserMedia({audio:!0});case 8:return i=t.sent,o=r.createMediaStreamSource(i),(a=new AudioWorkletNode(r,"audio-processor")).port.onmessage=e,n.signal=h,n.status=h.INIT,a.port.postMessage(n),o.connect(a),t.next=18,r.resume();case 18:return t.abrupt("return",{STREAM:i,SOURCE:o,WORKLETHREAD:a,AUDIOCONTEXT:r,POSTMESSAGE:a.port.postMessage});case 21:return t.prev=21,t.t0=t.catch(0),console.log(t.t0),t.abrupt("return",void 0);case 25:case"end":return t.stop()}}),t,null,[[0,21]])})))).apply(this,arguments)}const x=function(){var t,e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=(t=(0,l.useState)(0),e=2,function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=n){var r,i,o,a,s=[],u=!0,c=!1;try{if(o=(n=n.call(t)).next,0===e){if(Object(n)!==n)return;u=!1}else for(;!(u=(r=o.call(n)).done)&&(s.push(r.value),s.length!==e);u=!0);}catch(t){c=!0,i=t}finally{try{if(!u&&null!=n.return&&(a=n.return(),Object(a)!==a))return}finally{if(c)throw i}}return s}}(t,e)||y(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),i=r[0],o=r[1],a=(0,l.useRef)(void 0),s=(0,l.useRef)([]),u=(0,l.useRef)({volume:0,isSpeaking:!1}),c=(0,l.useRef)(null),f=((0,l.useRef)(null),function(t){var e;return null===(e=a.current)||void 0===e?void 0:e[t]});(0,l.useEffect)((function(){return function(){try{var t,e=f("SOURCE"),n=f("WORKLETHREAD"),r=f("AUDIOCONTEXT");e&&e.disconnect(),n&&n.disconnect(),r&&"closed"!==r.state&&r.suspend(),null===(t=f("STREAM"))||void 0===t||t.getTracks().forEach((function(t){return t.stop()}))}catch(t){console.error("cleanup errror")}}}),[]);var d=function(){var t=b(m().mark((function t(){var e,r,c;return m().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(0===i){t.next=3;break}return console.error("Session already running."),t.abrupt("return");case 3:if(t.prev=3,a.current){t.next=13;break}return e=n.ondataAvailable,n.ondataAvailable=void 0,t.next=9,A((function(t){var n=t.data;switch(n.status){case h.SPEAKING_STARTED:u.current.isSpeaking=!0;break;case h.SPEAKING_STOPED:u.current.isSpeaking=!1,console.log("called stop");var r=P(n.chunks,n.length);null==e||e(r);break;case 15:u.current.volume=n.volume,window.requestAnimationFrame((function(){s.current.forEach((function(t){t(u.current)}))}));break;default:console.log("not matching status key")}}),n);case 9:(r=t.sent)&&(a.current=r,o(1)),t.next=15;break;case 13:null===(c=f("AUDIOCONTEXT"))||void 0===c||c.resume(),o(1);case 15:t.next=20;break;case 17:t.prev=17,t.t0=t.catch(3),console.error("Microphone permission denied or error:",t.t0);case 20:case"end":return t.stop()}}),t,null,[[3,17]])})));return function(){return t.apply(this,arguments)}}();return{mediaRecorder:f("MEDIARECORDER"),MicState:i,Start:d,Pause:function(){var t;null===(t=f("AUDIOCONTEXT"))||void 0===t||t.suspend(),o(2)},Resume:function(){c.current&&2===i?(c.current.resumeRecording(),o(1)):console.error("Nothing to resume.")},Stop:function(){var t,e,n;t={status:h.STOP},null===(e=f("WORKLETHREAD"))||void 0===e||null===(e=e.port)||void 0===e||null===(n=e.postMessage)||void 0===n||n.call(e,t),o(0)},Subscribe:function(t){if(t&&"function"==typeof t)return s.current.push(t)-1},unSubscribe:function(t){"number"==typeof t&&t>=0&&t<s.current.length&&(s.current[t]=null)}}};function P(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:48e3,r=e||t.reduce((function(t,e){return t+e.length}),0),i=new ArrayBuffer(44+2*r),o=new DataView(i);T(o,0,"RIFF"),o.setUint32(4,36+2*r,!0),T(o,8,"WAVE"),T(o,12,"fmt "),o.setUint32(16,16,!0),o.setUint16(20,1,!0),o.setUint16(22,1,!0),o.setUint32(24,n,!0),o.setUint32(28,1*n*2,!0),o.setUint16(32,2,!0),o.setUint16(34,16,!0),T(o,36,"data"),o.setUint32(40,2*r,!0);var a,s=44,u=function(t){var e="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!e){if(Array.isArray(t)||(e=y(t))){e&&(t=e);var n=0,r=function(){};return{s:r,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,o=!0,a=!1;return{s:function(){e=e.call(t)},n:function(){var t=e.next();return o=t.done,t},e:function(t){a=!0,i=t},f:function(){try{o||null==e.return||e.return()}finally{if(a)throw i}}}}(t);try{for(u.s();!(a=u.n()).done;)for(var c=a.value,l=0;l<c.length;l++,s+=2)o.setInt16(s,c[l],!0)}catch(t){u.e(t)}finally{u.f()}return new Blob([i],{type:"audio/wav"})}function T(t,e,n){for(var r=0;r<n.length;r++)t.setUint8(e+r,n.charCodeAt(r))}return i})()));
//# sourceMappingURL=index.js.map