{"version":3,"file":"index.js","mappings":"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","sources":["webpack://react-audio-processor/webpack/universalModuleDefinition","webpack://react-audio-processor/external umd \"react\"","webpack://react-audio-processor/webpack/bootstrap","webpack://react-audio-processor/webpack/runtime/define property getters","webpack://react-audio-processor/webpack/runtime/hasOwnProperty shorthand","webpack://react-audio-processor/webpack/runtime/make namespace object","webpack://react-audio-processor/./src/audioProcessorV4.js","webpack://react-audio-processor/./src/useAudioProcessorKit.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"react\")) : factory(root[\"react\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__155__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__155__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\r\nexport const AUDIO_PROCESSOR_NAME = 'audio-processor';\r\nconst signal = {\r\n    PAUSE: 2,\r\n    RESUME: 4,\r\n    STOP: 3,\r\n    INIT: 1,\r\n    SPEAKING_STARTED: 10,\r\n    SPEAKING_STOPED: 12,\r\n}\r\n\r\n// ! important currenly 128 is contantly given in each channelData.length given are\r\n// by AudioWorkletProcessor documentation can have posiblity to change to more than 128 \r\n// so change to dynamic by using length . if found more than 128 currently  iam not able to \r\n// see more than 128 so to impove some performance i just add constant of 128\r\n\r\n/**\r\n * Akash v\r\n * email: akashv2000.dev@gmail.com\r\n * last update : 24-04-2025\r\n */\r\n\r\n\r\n\r\nconst AudioProcessor = `\r\n\r\nclass AudioProcessor extends AudioWorkletProcessor {\r\n\r\n    constructor() {\r\n        super();\r\n        console.log(\"Hello :) from AudioProcessor V4\");\r\n        this._readyTolisten = false;\r\n        this._needToSaveAudio = false;\r\n        this._enableVad = false;\r\n\r\n        /**\r\n         * WebAudio calls process() every time, we can't replace it.\r\n         * So we use _runtimeProcess inside it, and change _runtimeProcess\r\n         * to whatever function we need (like with VAD or without).\r\n         * This way we avoid if checks and get better performance.\r\n         */\r\n        this._runtimeProcess = () => true; // default dummy function\r\n\r\n        /**\r\n         * variables for vad feature\r\n         */\r\n        this._peakNoticedFrameCount = 0;\r\n        this._peakMaxFrame = 30;//sound start 60ms\r\n        this._silenceNoticedFrameCount = 0;\r\n        this._silentMaxFrame = 70; // 70 FRAME OF EACH 3MS TO 60*3 GIVES '180MS' OF SILENT MEANS TRIGGERS\r\n        this._facedAnyPeakVolume = false; // a variable which allow to vad to save if meet peak condtion\r\n\r\n        /**\r\n         * variables for need to save audio to record total session from start to stop\r\n         */\r\n        this._totalSessionLength = 0;\r\n        this._totalSession = [];\r\n\r\n        /**\r\n         * variables for need to save audio per given Time in frame or based on VAD\r\n         */\r\n        this._buffer2dArray16Bit = [];\r\n        this._buffer2dpreCaluculatingLength = 0;\r\n\r\n\r\n        /**\r\n         * for Volume level of audio needed for virtualization and others\r\n         * this rms volume data is update to main thread per the given frame\r\n         */\r\n        this._VolumeUpdateframe = 5; //15MS to get 60 frame rate like smooth\r\n        this._currentVolumeFrame = 0;\r\n\r\n        /***\r\n         * calls callback to get pass audio chunk data in nonvad senario data to main thread by  given frame time\r\n         */\r\n        this.secondsInFrame = 1000 / 3; //3 ms apprx be the time to call process , here 1s default time\r\n        this.currentSecondsIn = 0;\r\n\r\n\r\n\r\n\r\n        /**\r\n         *  Communicate with main thread\r\n         */\r\n        this.port.onmessage = (event) => {\r\n            const params = event.data;\r\n            switch (params.status) {\r\n                case 1://this.signal.INIT\r\n                    this._initialAssign(params);\r\n                    this._chooseProcess();\r\n\r\n                    break;\r\n                case this.signal.PAUSE:\r\n                    this._readyTolisten = false;\r\n\r\n                    break;\r\n                case this.signal.RESUME:\r\n                    this._readyTolisten = true;\r\n\r\n                    break;\r\n                case this.signal.STOP:\r\n                    this._readyTolisten = false;\r\n\r\n                    if (this._needToSaveAudio) {\r\n                        const transferList = this._totalSession.map(chunk => chunk.buffer);\r\n                        this.port.postMessage({\r\n                            status: this.signal.SPEAKING_STOPED,\r\n                            chunks: this._totalSession,\r\n                            length: this._totalSessionLength\r\n                        }, transferList);\r\n                        this._totalSession = [];\r\n                        this._totalSessionLength = 0;\r\n                    }\r\n\r\n                    break;\r\n                default:\r\n                    console.log(\"not matching status key\");\r\n            }\r\n        };\r\n    }\r\n\r\n    _initialAssign(params) {\r\n        this.signal = params.signal;\r\n        this._readyTolisten = true;\r\n        this.enableVad = params.enableVad;\r\n        this._needToSaveAudio = params.fullRecording;\r\n    }\r\n\r\n    /**\r\n     * logic to assign audioworklet process function to a function refrent  wich only do the nesscery work ,Not other things\r\n     *  to reduce performance\r\n     */\r\n    _chooseProcess() {\r\n        if (this.enableVad && this._needToSaveAudio) {\r\n            this._runtimeProcess = this.Process_With_Vad_And_FullRecording.bind(this);\r\n        } else if (this.enableVad) {\r\n            this._runtimeProcess = this.Process_With_Vad.bind(this);\r\n        } else {\r\n            this._runtimeProcess = this.Process_Without_vad_and_FullRecording.bind(this);\r\n        }\r\n        // why this pattern ? it reduce braching improve performance way more\r\n    }\r\n\r\n    /**\r\n     * Main function wich is called by browsers per approx 2 to 3 ms gap to give real audio buffers \r\n     * currently i made this way that this function can dynamically change its task \r\n     * by assiging any other function to  runtimeProcess this variable i used to\r\n     * assigin function dynamically that run inside this process ; \r\n     * this way i reduce condtions if-else usally happen when  pull all code inside this small tight loop\r\n     * \r\n     * This way very helpfully of removing cpu instuction branching , and make this very performant.\r\n     *  \r\n     */\r\n    process(inputs, outputs, parameters) { \r\n        if (!this._readyTolisten) return true; // Keep process alive by returning true\r\n\r\n        return this._runtimeProcess(inputs, outputs, parameters);\r\n    }\r\n\r\n    \r\n\r\n    Process_Without_vad_and_FullRecording(inputs, outputs, parameters) {\r\n\r\n        const input = inputs[0];\r\n\r\n        const channelData = input[0]; // taking first channel\r\n        if (this.currentSecondsIn > this.secondsInFrame) {\r\n            const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\r\n            this.port.postMessage({\r\n                status: this.signal.SPEAKING_STOPED,\r\n                // speaking: false,\r\n                chunks: this._buffer2dArray16Bit,\r\n                length: this._buffer2dpreCaluculatingLength\r\n            }, transferList);\r\n\r\n            this.currentSecondsIn = 0;\r\n            this._buffer2dArray16Bit = [];\r\n            this._buffer2dpreCaluculatingLength = 0;\r\n            return true;\r\n        } else {\r\n            this.currentSecondsIn++;\r\n        }\r\n        const converted16bit_array = this.float32ToInt16(channelData);\r\n        this._buffer2dArray16Bit.push(converted16bit_array);\r\n        this._buffer2dpreCaluculatingLength += converted16bit_array.length;\r\n\r\n        // Keep process alive\r\n        return true;\r\n    }\r\n\r\n\r\n    Process_With_Vad_And_FullRecording(inputs, outputs, parameters) {\r\n        const input = inputs[0];\r\n        if (input.length) {\r\n\r\n            const channelData = input[0]; // taking first channel\r\n            //faced any peak audio is important because it ensure we not passing empty data to backed\r\n            if (this.isSilent(channelData)) {\r\n\r\n                if (!this._facedAnyPeakVolume) {\r\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\r\n                    return true;   //early exit not valid audio\r\n                }\r\n\r\n\r\n                this._silenceNoticedFrameCount++;\r\n\r\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\r\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\r\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\r\n\r\n                    this.port.postMessage({\r\n                        status: this.signal.SPEAKING_STOPED,\r\n                        // speaking: false,\r\n                        chunks: this._buffer2dArray16Bit,\r\n                        length: this._buffer2dpreCaluculatingLength\r\n                    }, transferList);\r\n\r\n                    this._buffer2dArray16Bit = [];\r\n                    this._buffer2dpreCaluculatingLength = 0;\r\n                    this._silenceNoticedFrameCount = 0;\r\n                    this._facedAnyPeakVolume = false;\r\n                    this._peakNoticedFrameCount = 0;\r\n                    return true;\r\n                }\r\n\r\n\r\n            } else {\r\n                // here the logic is i show is speaking data after some real word passed so i wait 180 ms of continuos speach before declaring it is speaking\r\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\r\n                    // Notify UI that voice HEARD and may started speaking\r\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\r\n                    this._facedAnyPeakVolume = true;\r\n                }\r\n\r\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\r\n                this._silenceNoticedFrameCount = 0;\r\n\r\n            }\r\n\r\n            const converted16bit_array = this.float32ToInt16(channelData);\r\n            this._totalSession.push(new Int16Array(converted16bit_array));\r\n            this._buffer2dArray16Bit.push(converted16bit_array);\r\n            this._totalSessionLength += converted16bit_array.length;\r\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\r\n\r\n        }\r\n\r\n       // Keep process alive\r\n        return true;\r\n    }\r\n\r\n    Process_With_Vad(inputs, outputs, parameters) {\r\n        const input = inputs[0];\r\n        if (input.length) {\r\n\r\n            const channelData = input[0]; // taking first channel\r\n            //faced any peak audio is important because it ensure we not passing empty data to backed\r\n            if (this.isSilent(channelData)) {\r\n\r\n                if (!this._facedAnyPeakVolume) {\r\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\r\n                    return true;   //early exit not valid audio\r\n                }\r\n\r\n\r\n                this._silenceNoticedFrameCount++;\r\n\r\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\r\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\r\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\r\n\r\n                    this.port.postMessage({\r\n                        status: this.signal.SPEAKING_STOPED,\r\n                        // speaking: false,\r\n                        chunks: this._buffer2dArray16Bit,\r\n                        length: this._buffer2dpreCaluculatingLength\r\n                    }, transferList);\r\n\r\n                    this._buffer2dArray16Bit = [];\r\n                    this._buffer2dpreCaluculatingLength = 0;\r\n                    this._silenceNoticedFrameCount = 0;\r\n                    this._facedAnyPeakVolume = false;\r\n                    this._peakNoticedFrameCount = 0;\r\n                    return true;\r\n                }\r\n\r\n\r\n            } else {\r\n                // here the logic is To recogonise speaking i wait for some time to get notice peak voice\r\n               //  for some Milli second  of continuos speach before declaring it is speaking.\r\n\r\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\r\n                    // Notify UI that voice HEARD and may started speaking\r\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\r\n                    this._facedAnyPeakVolume = true;\r\n                }\r\n\r\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\r\n                this._silenceNoticedFrameCount = 0;\r\n\r\n            }\r\n\r\n            const converted16bit_array = this.float32ToInt16(channelData);\r\n            this._buffer2dArray16Bit.push(converted16bit_array);\r\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\r\n        }\r\n\r\n        // Keep process alive\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert 32 bit float to 16 bit int\r\n     * example\r\n     * [\r\n     *  1.99999988079071044921875  to normalize between 16 bit int meaning convert under 35000\r\n     *  by just multipling point number to 35000 and also (32000 for negative value )\r\n     *  by this we get convert 32 bit to 16 bit\r\n     *  int\r\n     * ]\r\n     * @param {*} float32Array\r\n     * @returns INTEGER\r\n     */\r\n    float32ToInt16(float32Array) {\r\n        const int16Array = new Int16Array(128);\r\n        for (let i = 0; i < 128; i++) {\r\n            let s = Math.max(-1, Math.min(1, float32Array[i]));\r\n            int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\r\n        }\r\n        return int16Array;\r\n    }\r\n\r\n    /**\r\n     * get silent and peak from value under 0 to 1\r\n     *\r\n     * v3 - new changes\r\n     * In this version i simply only checking half value\r\n     * it is ok till we get positive result same reslt not major accurasy issue\r\n     * and get performance bost\r\n     *\r\n     * @param {*} buffer\r\n     * @returns float\r\n     */\r\n    getRMS(buffer) {\r\n        let sumSquares = 0;\r\n        /**\r\n         * idea is to get a single value from 0 to 1 from all 128 values from this list;\r\n         * mathematically just 20/100 gives 0.2 like that adding each  give 128 value and total is 128.\r\n         * which is 128/128 gives 1\r\n         *\r\n         * this is base idea other than it all normallization of each single 128 value\r\n         * like if value is minus making is positive ,  any way it will not exede 1 so allways\r\n         * its total lesst than or equal to 128 why becaous is each maxmimum is 1 then 1*128 gives 128\r\n         *\r\n         * finally sqaure rooting to get lowest round value we are doing this\r\n         * without it also we can work in this\r\n         *\r\n         */\r\n        for (let i = 0; i < 128; i++) {\r\n            sumSquares += buffer[i] * buffer[i];\r\n        }\r\n        /**\r\n         *  here constent 0.0078125 equivalent of 128  basically iam doing division in fastest way\r\n         *  multiplicational divition is faster than actual division in cpu\r\n         *  1/128 gives 0.0078125 simply just multiply by it you get its value\r\n         */\r\n        return Math.sqrt(sumSquares * 0.0078125);\r\n    }\r\n\r\n    /**\r\n     * analyse for silence in audio bit\r\n     * with our given constant value\r\n     * @param {*} buffer 128 32bit float\r\n     * @returns boolean\r\n     */\r\n    isSilent(buffer) {\r\n        const rms = this.getRMS(buffer);\r\n        // this.port.postMessage({\r\n        //     status: 15,\r\n        //     volume: rms,\r\n        // });\r\n        if (this._currentVolumeFrame > this._VolumeUpdateframe) {\r\n            this._currentVolumeFrame = 0;\r\n            this.port.postMessage({\r\n                status: 15,\r\n                volume: rms,\r\n            });\r\n        } else {\r\n            this._currentVolumeFrame++;\r\n        }\r\n\r\n        return rms < 0.003;\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n   registerProcessor('audio-processor', AudioProcessor);\r\n`;\r\n\r\n// Convert string to Blob and Object URL\r\nconst blob = new Blob([AudioProcessor], { type: 'application/javascript' });\r\nconst url = URL.createObjectURL(blob);\r\n\r\n\r\n\r\nexport { url, signal };\r\n\r\n","import { useEffect, useRef, useState } from \"react\";\r\nimport { url, AUDIO_PROCESSOR_NAME, signal } from './audioProcessorV4.js'\r\n\r\n\r\n\r\n\r\n\r\n//------------------------------------------------CONSTANTS end here -----------------------------------------------\r\n\r\n/**\r\n * !NOTE!\r\n * \r\n * AUDIOCONTEXT WITH AUDIOPROCESSOR - Initalization\r\n * very important\r\n * idea is to create single audioContext with audioProcessor otherwise it may heavy to mobile/old devices\r\n */\r\nconst audioContext = new (window?.AudioContext || window?.webkitAudioContext)();\r\nconst promiseAudioContext = audioContext?.audioWorklet?.addModule?.(url);\r\n\r\npromiseAudioContext?.catch?.((e) => {\r\n    console.log(\"not able add addModule audioProcessor.js \")\r\n})\r\nasync function isAudioContextReady() {\r\n    try {\r\n        if (!promiseAudioContext) throw new Error(\"issue with initializing audioWorklet addModule , please use https or localhost\");\r\n\r\n        await promiseAudioContext\r\n        return audioContext;\r\n    } catch (e) {\r\n        console.error(e);\r\n        return undefined\r\n    }\r\n}\r\n//------------------------------------------------AUDIOCONTEXT WITH AUDIOPROCESSOR init end here -----------------------------------------------\r\n\r\n\r\n\r\n\r\nconst Static_MicState = {\r\n    STOPPED: 0,\r\n    RECORDING: 1,\r\n    PAUSED: 2\r\n};\r\n\r\nasync function init(onMessage, options) {\r\n    try {\r\n        const audioContextInstance = await isAudioContextReady();\r\n        if (!audioContextInstance) throw new Error(\"issue with initializing audioContext\");\r\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n        //const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });\r\n\r\n        const source = audioContextInstance.createMediaStreamSource(stream);\r\n        const workletNodeThread = new AudioWorkletNode(audioContextInstance, AUDIO_PROCESSOR_NAME);\r\n        //=== attaching call back of main thread  so from audioworklet thread can call this callbacks ====\r\n        workletNodeThread.port.onmessage = onMessage;\r\n\r\n        //=== passing initial of settings to audio thread\r\n        options[\"signal\"] = signal;\r\n        options[\"status\"] = signal.INIT;\r\n        workletNodeThread.port.postMessage(options);\r\n\r\n        source.connect(workletNodeThread);\r\n        await audioContextInstance.resume();\r\n        return { STREAM: stream, SOURCE: source, WORKLETHREAD: workletNodeThread, AUDIOCONTEXT: audioContextInstance, POSTMESSAGE: workletNodeThread.port.postMessage };\r\n\r\n    } catch (e) {\r\n        console.log(e);\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Akash v\r\n * email: akashv2000.dev@gmail.com\r\n * last update : 25-04-2025\r\n */\r\nfunction useAudioProcessorKit(parameters = {}) {\r\n    const [MicState, setMicState] = useState(Static_MicState.STOPPED);\r\n    const initialMainAudioResources = useRef(undefined);\r\n\r\n    //======Subscribe way run each small componensts function so reducing maximum reload of component ========\r\n    const subscribeCallback = useRef([]);\r\n    const values = useRef({\r\n        volume: 0,\r\n        isSpeaking: false,\r\n    });\r\n\r\n    // seperate thread which run process \r\n\r\n    const recorderRef = useRef(null);\r\n    const streamRef = useRef(null);\r\n\r\n    const getCurrent = (KEY) => {\r\n        return initialMainAudioResources.current?.[KEY];\r\n    }\r\n    const postMessage = (params) => {\r\n        getCurrent(\"WORKLETHREAD\")?.port?.postMessage?.(params);\r\n    }\r\n\r\n    useEffect(() => {\r\n        return () => {\r\n            try {\r\n                const source = getCurrent(\"SOURCE\");\r\n                const workletthread = getCurrent(\"WORKLETHREAD\");\r\n                const audioContext = getCurrent(\"AUDIOCONTEXT\");\r\n                source && source.disconnect();\r\n                workletthread && workletthread.disconnect();\r\n                if (audioContext && audioContext.state !== 'closed') {\r\n                    audioContext.suspend(); // we only create one instance per on browser tab so no close\r\n                }\r\n                getCurrent(\"STREAM\")?.getTracks().forEach((track) => track.stop());\r\n            } catch (error) {\r\n                console.error(\"cleanup errror\");\r\n            }\r\n        }\r\n    }, [])\r\n\r\n\r\n    const Subscribe = (callback) => {\r\n        if (callback && typeof callback === \"function\") {\r\n            return subscribeCallback.current.push(callback) - 1;\r\n\r\n        }\r\n    };\r\n\r\n    const unSubscribe = (index) => {\r\n        if (typeof index === \"number\" && index >= 0 && index < subscribeCallback.current.length) {\r\n            subscribeCallback.current[index] = null;// not remove if remove all index change lead wrong unsubscribe by other compoenrrs\r\n        }\r\n    };\r\n\r\n\r\n\r\n\r\n\r\n\r\n    const Start = async () => {\r\n        if (MicState !== Static_MicState.STOPPED) {\r\n            console.error(\"Session already running.\");\r\n            return;\r\n        }\r\n\r\n        try {\r\n\r\n            if (!initialMainAudioResources.current) {\r\n                const ondataAvailable = parameters.ondataAvailable;\r\n                parameters.ondataAvailable = undefined;\r\n                const AudioRefrence = await init((event) => {\r\n                    const data = event.data;\r\n                    switch (data.status) {\r\n                        case signal.SPEAKING_STARTED:\r\n                            values.current[\"isSpeaking\"] = true;\r\n                            break;\r\n                        case signal.SPEAKING_STOPED:\r\n                            values.current[\"isSpeaking\"] = false;\r\n                            console.log(\"called stop\");\r\n                            /**\r\n                             * encode 16bit integer chunk  to wav formate, just add a light weight header, \r\n                             */\r\n                            const wavChunk = encodeWav(data.chunks, data.length);\r\n                            ondataAvailable?.(wavChunk);\r\n                            // call the callback onDataAvailable\r\n                            break;\r\n                        case 15:// included on enabling vad\r\n                            values.current[\"volume\"] = data.volume;\r\n                            window.requestAnimationFrame(() => {\r\n                                subscribeCallback.current.forEach((callbackFn) => {\r\n                                    callbackFn(values.current);\r\n                                })\r\n                            });\r\n\r\n                            break;\r\n                        default:\r\n                            console.log(\"not matching status key\");\r\n                    }\r\n\r\n\r\n                }, parameters);\r\n\r\n                if (AudioRefrence) {\r\n                    initialMainAudioResources.current = AudioRefrence;\r\n                    //getCurrent(\"AUDIOCONTEXT\")?.resume();\r\n                    setMicState(Static_MicState.RECORDING);\r\n                }\r\n\r\n            } else {\r\n                getCurrent(\"AUDIOCONTEXT\")?.resume();\r\n                setMicState(Static_MicState.RECORDING);\r\n            }\r\n\r\n        } catch (err) {\r\n            console.error(\"Microphone permission denied or error:\", err);\r\n        }\r\n    };\r\n\r\n    const Pause = () => {\r\n        getCurrent(\"AUDIOCONTEXT\")?.suspend();\r\n        setMicState(Static_MicState.PAUSED);\r\n\r\n        // if (recorderRef.current && MicState === Static_MicState.RECORDING) {\r\n        //     recorderRef.current.pauseRecording();\r\n        //     setMicState(Static_MicState.PAUSED);\r\n        // } else {\r\n        //     console.error(\"No active session to pause.\");\r\n        // }\r\n    };\r\n\r\n    const Resume = () => {\r\n        if (recorderRef.current && MicState === Static_MicState.PAUSED) {\r\n            recorderRef.current.resumeRecording();\r\n            setMicState(Static_MicState.RECORDING);\r\n        } else {\r\n            console.error(\"Nothing to resume.\");\r\n        }\r\n    };\r\n\r\n    const Stop = () => {\r\n        postMessage({ status: signal.STOP });\r\n        setMicState(0);\r\n        // if (recorderRef.current && MicState !== Static_MicState.STOPPED) {\r\n        //     recorderRef.current.stopRecording(() => {\r\n        //         const audioBlob = recorderRef.current.getBlob();\r\n\r\n        //         recorderRef.current.destroy();\r\n        //         recorderRef.current = null;\r\n\r\n        //         streamRef.current?.getTracks().forEach((track) => track.stop());\r\n        //         streamRef.current = null;\r\n        //         setMicState(Static_MicState.STOPPED);\r\n        //     });\r\n        // } else {\r\n        //     console.error(\"Nothing to stop.\");\r\n        // }\r\n    };\r\n\r\n    return {\r\n        mediaRecorder: getCurrent(\"MEDIARECORDER\"),\r\n        MicState,\r\n        Start,\r\n        Pause,\r\n        Resume,\r\n        Stop,\r\n        Subscribe,\r\n        unSubscribe\r\n    };\r\n}\r\n\r\nexport default useAudioProcessorKit;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction encodeWav(int16ArrayChunks, length, sampleRate = 48000) {\r\n    const bytesPerSample = 2;\r\n    const numChannels = 1;\r\n\r\n    const totalLength = length || int16ArrayChunks.reduce((sum, arr) => sum + arr.length, 0);\r\n    const buffer = new ArrayBuffer(44 + totalLength * bytesPerSample);\r\n    const view = new DataView(buffer);\r\n\r\n    // ===== Write WAV header =====\r\n    writeString(view, 0, 'RIFF'); // ChunkID\r\n    view.setUint32(4, 36 + totalLength * bytesPerSample, true); // ChunkSize\r\n    writeString(view, 8, 'WAVE'); // Format\r\n\r\n    writeString(view, 12, 'fmt '); // Subchunk1ID\r\n    view.setUint32(16, 16, true); // Subchunk1Size (PCM)\r\n    view.setUint16(20, 1, true);  // AudioFormat (1 = PCM)\r\n    view.setUint16(22, numChannels, true); // NumChannels\r\n    view.setUint32(24, sampleRate, true); // SampleRate\r\n    view.setUint32(28, sampleRate * numChannels * bytesPerSample, true); // ByteRate\r\n    view.setUint16(32, numChannels * bytesPerSample, true); // BlockAlign\r\n    view.setUint16(34, 16, true); // BitsPerSample\r\n\r\n    writeString(view, 36, 'data'); // Subchunk2ID\r\n    view.setUint32(40, totalLength * bytesPerSample, true); // Subchunk2Size\r\n\r\n    // ===== Write PCM samples =====\r\n    let offset = 44;\r\n    for (const chunk of int16ArrayChunks) {\r\n        for (let i = 0; i < chunk.length; i++, offset += 2) {\r\n            view.setInt16(offset, chunk[i], true); // Little-endian PCM\r\n        }\r\n    }\r\n\r\n    return new Blob([buffer], { type: 'audio/wav' });\r\n}\r\n\r\nfunction writeString(view, offset, str) {\r\n    for (let i = 0; i < str.length; i++) {\r\n        view.setUint8(offset + i, str.charCodeAt(i));\r\n    }\r\n}\r\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__155__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","signal","PAUSE","RESUME","STOP","INIT","SPEAKING_STARTED","SPEAKING_STOPED","blob","Blob","type","url","URL","createObjectURL","_regeneratorRuntime","e","t","n","iterator","c","asyncIterator","u","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","arg","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","getPrototypeOf","v","values","g","defineIteratorMethods","forEach","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","delegateYield","_unsupportedIterableToArray","_arrayLikeToArray","toString","Array","from","test","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","audioContext","_window","window","AudioContext","_window2","webkitAudioContext","promiseAudioContext","_audioContext$audioWo","audioWorklet","_audioContext$audioWo2","addModule","isAudioContextReady","_isAudioContextReady","_callee2","_context2","t0","console","error","_promiseAudioContext$","log","init","_x","_x2","_init","_callee3","onMessage","options","audioContextInstance","stream","source","workletNodeThread","_context3","navigator","mediaDevices","getUserMedia","audio","createMediaStreamSource","AudioWorkletNode","port","onmessage","postMessage","connect","resume","STREAM","SOURCE","WORKLETHREAD","AUDIOCONTEXT","POSTMESSAGE","parameters","_useState2","useState","isArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","MicState","setMicState","initialMainAudioResources","useRef","subscribeCallback","volume","isSpeaking","recorderRef","getCurrent","KEY","_initialMainAudioReso","current","useEffect","_getCurrent2","workletthread","disconnect","state","suspend","getTracks","track","Start","_ref","_callee","ondataAvailable","AudioRefrence","_getCurrent3","_context","event","data","status","wavChunk","encodeWav","chunks","requestAnimationFrame","callbackFn","mediaRecorder","Pause","_getCurrent4","Resume","resumeRecording","Stop","params","_getCurrent","_getCurrent$postMessa","Subscribe","callback","unSubscribe","index","int16ArrayChunks","sampleRate","totalLength","reduce","sum","arr","buffer","ArrayBuffer","view","DataView","writeString","setUint32","setUint16","numChannels","_step","offset","_iterator","_createForOfIteratorHelper","chunk","setInt16","err","str","setUint8","charCodeAt"],"sourceRoot":""}