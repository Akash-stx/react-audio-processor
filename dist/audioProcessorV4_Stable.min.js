"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.url=exports.signal=exports.AUDIO_PROCESSOR_NAME=void 0;var AUDIO_PROCESSOR_NAME=exports.AUDIO_PROCESSOR_NAME="audio-processor";var signal=exports.signal={PAUSE:2,RESUME:4,STOP:3,INIT:1,SPEAKING_STARTED:10,SPEAKING_STOPED:12};// ! important currenly 128 is contantly given in each channelData.length given are
// by AudioWorkletProcessor documentation can have posiblity to change to more than 128 
// so change to dynamic by using length . if found more than 128 currently  iam not able to 
// see more than 128 so to impove some performance i just add constant of 128
/**
 * Akash v
 * email: akashv2000.dev@gmail.com
 * last update : 24-04-2025
 */var AudioProcessor="\n\nclass AudioProcessor extends AudioWorkletProcessor {\n\n    constructor() {\n        super();\n        console.log(\"Hello :) from AudioProcessor V4\");\n        this._readyTolisten = false;\n        this._needToSaveAudio = false;\n        this._enableVad = false;\n\n        /**\n         * WebAudio calls process() every time, we can't replace it.\n         * So we use _runtimeProcess inside it, and change _runtimeProcess\n         * to whatever function we need (like with VAD or without).\n         * This way we avoid if checks and get better performance.\n         */\n        this._runtimeProcess = () => true; // default dummy function\n\n        /**\n         * variables for vad feature\n         */\n        this._peakNoticedFrameCount = 0;\n        this._peakMaxFrame = 30;//sound start 60ms\n        this._silenceNoticedFrameCount = 0;\n        this._silentMaxFrame = 70; // 70 FRAME OF EACH 3MS TO 60*3 GIVES '180MS' OF SILENT MEANS TRIGGERS\n        this._facedAnyPeakVolume = false; // a variable which allow to vad to save if meet peak condtion\n\n        /**\n         * variables for need to save audio to record total session from start to stop\n         */\n        this._totalSessionLength = 0;\n        this._totalSession = [];\n\n        /**\n         * variables for need to save audio per given Time in frame or based on VAD\n         */\n        this._buffer2dArray16Bit = [];\n        this._buffer2dpreCaluculatingLength = 0;\n\n\n        /**\n         * for Volume level of audio needed for virtualization and others\n         * this rms volume data is update to main thread per the given frame\n         */\n        this._VolumeUpdateframe = 5; //15MS to get 60 frame rate like smooth\n        this._currentVolumeFrame = 0;\n\n        /***\n         * calls callback to get pass audio chunk data in nonvad senario data to main thread by  given frame time\n         */\n        this.secondsInFrame = 1000 / 3; //3 ms apprx be the time to call process , here 1s default time\n        this.currentSecondsIn = 0;\n\n\n\n\n        /**\n         *  Communicate with main thread\n         */\n        this.port.onmessage = (event) => {\n            const params = event.data;\n            switch (params.status) {\n                case 1://this.signal.INIT\n                    this._initialAssign(params);\n                    this._chooseProcess();\n\n                    break;\n                case this.signal.PAUSE:\n                    this._readyTolisten = false;\n\n                    break;\n                case this.signal.RESUME:\n                    this._readyTolisten = true;\n\n                    break;\n                case this.signal.STOP:\n                    this._readyTolisten = false;\n\n                    if (this._needToSaveAudio) {\n                        const transferList = this._totalSession.map(chunk => chunk.buffer);\n                        this.port.postMessage({\n                            status: this.signal.SPEAKING_STOPED,\n                            chunks: this._totalSession,\n                            length: this._totalSessionLength\n                        }, transferList);\n                        this._totalSession = [];\n                        this._totalSessionLength = 0;\n                    }\n\n                    break;\n                default:\n                    console.log(\"not matching status key\");\n            }\n        };\n    }\n\n    _initialAssign(params) {\n        this.signal = params.signal;\n        this._readyTolisten = true;\n        this.enableVad = params.enableVad;\n        this._needToSaveAudio = params.fullRecording;\n    }\n\n    /**\n     * logic to assign audioworklet process function to a function refrent  wich only do the nesscery work ,Not other things\n     *  to reduce performance\n     */\n    _chooseProcess() {\n        if (this.enableVad && this._needToSaveAudio) {\n            this._runtimeProcess = this.Process_With_Vad_And_FullRecording.bind(this);\n        } else if (this.enableVad) {\n            this._runtimeProcess = this.Process_With_Vad.bind(this);\n        } else {\n            this._runtimeProcess = this.Process_Without_vad_and_FullRecording.bind(this);\n        }\n        // why this pattern ? it reduce braching improve performance way more\n    }\n\n    /**\n     * Main function wich is called by browsers per approx 2 to 3 ms gap to give real audio buffers \n     * currently i made this way that this function can dynamically change its task \n     * by assiging any other function to  runtimeProcess this variable i used to\n     * assigin function dynamically that run inside this process ; \n     * this way i reduce condtions if-else usally happen when  pull all code inside this small tight loop\n     * \n     * This way very helpfully of removing cpu instuction branching , and make this very performant.\n     *  \n     */\n    process(inputs, outputs, parameters) { \n        if (!this._readyTolisten) return true; // Keep process alive by returning true\n\n        return this._runtimeProcess(inputs, outputs, parameters);\n    }\n\n    \n\n    Process_Without_vad_and_FullRecording(inputs, outputs, parameters) {\n\n        const input = inputs[0];\n\n        const channelData = input[0]; // taking first channel\n        if (this.currentSecondsIn > this.secondsInFrame) {\n            const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n            this.port.postMessage({\n                status: this.signal.SPEAKING_STOPED,\n                // speaking: false,\n                chunks: this._buffer2dArray16Bit,\n                length: this._buffer2dpreCaluculatingLength\n            }, transferList);\n\n            this.currentSecondsIn = 0;\n            this._buffer2dArray16Bit = [];\n            this._buffer2dpreCaluculatingLength = 0;\n            return true;\n        } else {\n            this.currentSecondsIn++;\n        }\n        const converted16bit_array = this.float32ToInt16(channelData);\n        this._buffer2dArray16Bit.push(converted16bit_array);\n        this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n\n        // Keep process alive\n        return true;\n    }\n\n\n    Process_With_Vad_And_FullRecording(inputs, outputs, parameters) {\n        const input = inputs[0];\n        if (input.length) {\n\n            const channelData = input[0]; // taking first channel\n            //faced any peak audio is important because it ensure we not passing empty data to backed\n            if (this.isSilent(channelData)) {\n\n                if (!this._facedAnyPeakVolume) {\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\n                    return true;   //early exit not valid audio\n                }\n\n\n                this._silenceNoticedFrameCount++;\n\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n\n                    this.port.postMessage({\n                        status: this.signal.SPEAKING_STOPED,\n                        // speaking: false,\n                        chunks: this._buffer2dArray16Bit,\n                        length: this._buffer2dpreCaluculatingLength\n                    }, transferList);\n\n                    this._buffer2dArray16Bit = [];\n                    this._buffer2dpreCaluculatingLength = 0;\n                    this._silenceNoticedFrameCount = 0;\n                    this._facedAnyPeakVolume = false;\n                    this._peakNoticedFrameCount = 0;\n                    return true;\n                }\n\n\n            } else {\n                // here the logic is i show is speaking data after some real word passed so i wait 180 ms of continuos speach before declaring it is speaking\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\n                    // Notify UI that voice HEARD and may started speaking\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\n                    this._facedAnyPeakVolume = true;\n                }\n\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\n                this._silenceNoticedFrameCount = 0;\n\n            }\n\n            const converted16bit_array = this.float32ToInt16(channelData);\n            this._totalSession.push(new Int16Array(converted16bit_array));\n            this._buffer2dArray16Bit.push(converted16bit_array);\n            this._totalSessionLength += converted16bit_array.length;\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n\n        }\n\n       // Keep process alive\n        return true;\n    }\n\n    Process_With_Vad(inputs, outputs, parameters) {\n        const input = inputs[0];\n        if (input.length) {\n\n            const channelData = input[0]; // taking first channel\n            //faced any peak audio is important because it ensure we not passing empty data to backed\n            if (this.isSilent(channelData)) {\n\n                if (!this._facedAnyPeakVolume) {\n                    this._peakNoticedFrameCount && (this._peakNoticedFrameCount = 0);\n                    return true;   //early exit not valid audio\n                }\n\n\n                this._silenceNoticedFrameCount++;\n\n                //60 FRAME OF EACH 3MS TO 60*3 GIVES '180MS'\n                if (this._silenceNoticedFrameCount > this._silentMaxFrame) {\n                    const transferList = this._buffer2dArray16Bit.map(chunk => chunk.buffer);\n\n                    this.port.postMessage({\n                        status: this.signal.SPEAKING_STOPED,\n                        // speaking: false,\n                        chunks: this._buffer2dArray16Bit,\n                        length: this._buffer2dpreCaluculatingLength\n                    }, transferList);\n\n                    this._buffer2dArray16Bit = [];\n                    this._buffer2dpreCaluculatingLength = 0;\n                    this._silenceNoticedFrameCount = 0;\n                    this._facedAnyPeakVolume = false;\n                    this._peakNoticedFrameCount = 0;\n                    return true;\n                }\n\n\n            } else {\n                // here the logic is To recogonise speaking i wait for some time to get notice peak voice\n               //  for some Milli second  of continuos speach before declaring it is speaking.\n\n                if ((!this._facedAnyPeakVolume) && this._peakNoticedFrameCount > this._peakMaxFrame) {\n                    // Notify UI that voice HEARD and may started speaking\n                    this.port.postMessage({ status: this.signal.SPEAKING_STARTED });\n                    this._facedAnyPeakVolume = true;\n                }\n\n                !this._facedAnyPeakVolume && this._peakNoticedFrameCount++;\n                this._silenceNoticedFrameCount = 0;\n\n            }\n\n            const converted16bit_array = this.float32ToInt16(channelData);\n            this._buffer2dArray16Bit.push(converted16bit_array);\n            this._buffer2dpreCaluculatingLength += converted16bit_array.length;\n        }\n\n        // Keep process alive\n        return true;\n    }\n\n\n    /**\n     * Convert 32 bit float to 16 bit int\n     * example\n     * [\n     *  1.99999988079071044921875  to normalize between 16 bit int meaning convert under 35000\n     *  by just multipling point number to 35000 and also (32000 for negative value )\n     *  by this we get convert 32 bit to 16 bit\n     *  int\n     * ]\n     * @param {*} float32Array\n     * @returns INTEGER\n     */\n    float32ToInt16(float32Array) {\n        const int16Array = new Int16Array(128);\n        for (let i = 0; i < 128; i++) {\n            let s = Math.max(-1, Math.min(1, float32Array[i]));\n            int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n        }\n        return int16Array;\n    }\n\n    /**\n     * get silent and peak from value under 0 to 1\n     *\n     * v3 - new changes\n     * In this version i simply only checking half value\n     * it is ok till we get positive result same reslt not major accurasy issue\n     * and get performance bost\n     *\n     * @param {*} buffer\n     * @returns float\n     */\n    getRMS(buffer) {\n        let sumSquares = 0;\n        /**\n         * idea is to get a single value from 0 to 1 from all 128 values from this list;\n         * mathematically just 20/100 gives 0.2 like that adding each  give 128 value and total is 128.\n         * which is 128/128 gives 1\n         *\n         * this is base idea other than it all normallization of each single 128 value\n         * like if value is minus making is positive ,  any way it will not exede 1 so allways\n         * its total lesst than or equal to 128 why becaous is each maxmimum is 1 then 1*128 gives 128\n         *\n         * finally sqaure rooting to get lowest round value we are doing this\n         * without it also we can work in this\n         *\n         */\n        for (let i = 0; i < 128; i++) {\n            sumSquares += buffer[i] * buffer[i];\n        }\n        /**\n         *  here constent 0.0078125 equivalent of 128  basically iam doing division in fastest way\n         *  multiplicational divition is faster than actual division in cpu\n         *  1/128 gives 0.0078125 simply just multiply by it you get its value\n         */\n        return Math.sqrt(sumSquares * 0.0078125);\n    }\n\n    /**\n     * analyse for silence in audio bit\n     * with our given constant value\n     * @param {*} buffer 128 32bit float\n     * @returns boolean\n     */\n    isSilent(buffer) {\n        const rms = this.getRMS(buffer);\n        // this.port.postMessage({\n        //     status: 15,\n        //     volume: rms,\n        // });\n        if (this._currentVolumeFrame > this._VolumeUpdateframe) {\n            this._currentVolumeFrame = 0;\n            this.port.postMessage({\n                status: 15,\n                volume: rms,\n            });\n        } else {\n            this._currentVolumeFrame++;\n        }\n\n        return rms < 0.003;\n    }\n\n\n\n}\n\n\n   registerProcessor('audio-processor', AudioProcessor);\n";// Convert string to Blob and Object URL
var blob=new Blob([AudioProcessor],{type:"application/javascript"});var url=exports.url=URL.createObjectURL(blob);